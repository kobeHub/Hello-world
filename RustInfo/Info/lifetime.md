# 生命周期

[TOC]

## 1. 使用情景

Rust 中的每一个引用都有其保持的作用域，称之为生命周期。大部分的引用的生命周期可以进行推断，正如大部分的类型可以推断，但是对于可能存在歧义的情形，必须注明一个具体的类型。所以对于一些引用也需要注明生命周期。以此来确保一个引用一定有效。**某种程度上说，不同于其他语言中的类似工具，可以说这是Rust中最独特的部分。**

### 生命周期避免了垂直引用

垂直引用是指导致程序非预期引用的数据，一般的情形使用一个在一个已经结束的作用中生命的引用。

```rust
{
    let r;
    {
        let x = 5;
        r = &x
    }  // x dropped here while still borrowed 
    println!("{}", r)   // 
}
```

以上代码产生一个编译错误,不允许一个作用与已经结束的变量被借用。

### 借用检查器

Rust 编译器有一个借用检查器（borrow checker），通过比较作用域来保证所有的借用都是正确的。一个有效的引用赋值必须满足**将一个较大的生命周期的变量借用给一个较短的生命周期的引用。**

```rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}           
```

## 2. 函数中的泛型生命周期

对于一个返回两个字符串切片中的较长者的函数，对于传入的两个`&str`参数，直接的函数实现会报错，因为没有注明生命周期。可以使用注释语法`annoations`

```rust
&i32 
&'a i32
&'a mut i32
```

单个引用的生命周期注释没有太大意义，因为生命周期的主要作用是告诉rust多个引用的生命周期是如何进行联系的。两个具有相同注释的引用的存在时间必须相同。通过注明生命周期，可以实现以上函数：

```rust
pub fn str_longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

函数获取的