# 无畏并发

Rust 的所有权系统以及类型安全系统是一系列解决**内存安全**以及**并发问题**的强有力工具。通过所有权以及类型检查，大多数错误发生在编译期，而非运行时错误。本章主要涉及以下内容:

+ 如何创建线程并行运行多段代码
+ **消息传递**(Message passing) 并发，其中channel用于在线程间传递信息
+ **共享状态**（state sharing）并发，其中多个线程可以访问同一片数据
+ `Sync`以及`Send` trait，允许Rust并发扩展到标准库以及自定义类型中

## 1. Rust 线程定义

大部分现代操作系统中，执行程序的代码运行于一个进程中，或者有多个线程独立运行。使用多个线程可以改善性能，但会增加复杂性，导致问题：

+ 竞争状态
+ 死锁
+ 只会发生在特定情况且难以稳定重现和修复的 bug

编程语言具有不同的方法实现线程，很多操作系统提供了创建线程的API，由编程语言调用操作系统API创建线程的模型，语言线程与系统线程是1:1 的。很多编程语言提供了自己特殊的线程实现。编程语言提供的线程被称为 **绿色**（*green*）线程，使用绿色线程的语言会在不同数量的 OS 线程的上下文中执行它们。为此，绿色线程模式被称为 *M:N* 模型：`M` 个绿色线程对应 `N` 个 OS 线程，这里 `M` 和 `N` 不必相同。

每一个模型都有其取舍。**运行时**代表了二进制文件中，由语言自身提供的代码，任何非汇编语言都有一定的运行时代码。更小的运行时拥有更少的功能不过其优势在于更小的二进制输出，这使其易于在更多上下文中与其他语言相结合。虽然很多语言觉得增加运行时来换取更多功能没有什么问题，但是 Rust 需要做到几乎没有运行时，同时为了保持高性能必需能够调用 C 语言，这点也是不能妥协的。Rust，标准库中提供了1:1模型，有其他crate提供M：N模型。

## 2. 线程与`move`闭包

`move`闭包，可以强制闭包获取其所使用的环境值的所有权，配合`thread::spawn`使用，可以在闭包传递给新线程的同时将数据移动到新线程。

为了在新建线程中使用主线程数据，需要新建线程的闭包获取数据所有权:

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

